(window.webpackJsonp=window.webpackJsonp||[]).push([[174],{499:function(t,e,a){"use strict";a.r(e);var r=a(0),s=Object(r.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"computer与watch"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#computer与watch"}},[t._v("#")]),t._v(" computer与watch")]),t._v(" "),a("p",[t._v("前言： 普通监听对象就是监听他的内存地址")]),t._v(" "),a("h2",{attrs:{id:"computer"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#computer"}},[t._v("#")]),t._v(" computer")]),t._v(" "),a("h3",{attrs:{id:"具有get和set方法；而且具有缓存-依赖属性不变则不会重新执行函数，性能更好-。"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#具有get和set方法；而且具有缓存-依赖属性不变则不会重新执行函数，性能更好-。"}},[t._v("#")]),t._v(" 具有get和set方法；而且具有缓存(依赖属性不变则不会重新执行函数，性能更好)。")]),t._v(" "),a("ul",[a("li",[t._v("set接收一个newVal")]),t._v(" "),a("li",[t._v("缓存的原理：https://juejin.im/post/5e8fd7a3f265da47c35d7d29#comment")])]),t._v(" "),a("h2",{attrs:{id:"watch"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#watch"}},[t._v("#")]),t._v(" watch")]),t._v(" "),a("h3",{attrs:{id:"通过handler与deep-true来支持深度监听，通过immediate首次监听。"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#通过handler与deep-true来支持深度监听，通过immediate首次监听。"}},[t._v("#")]),t._v(" 通过handler与deep: true来支持深度监听，通过immediate首次监听。")]),t._v(" "),a("h4",{attrs:{id:"注意1：handler里的this指向问题，不能使用箭头函数；"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#注意1：handler里的this指向问题，不能使用箭头函数；"}},[t._v("#")]),t._v(" 注意1：handler里的this指向问题，不能使用箭头函数；")]),t._v(" "),a("blockquote",[a("ul",[a("li",[t._v("使用了箭头函数this就不会指向当前的vueComponent对象")])])]),t._v(" "),a("h4",{attrs:{id:"注意2：如果需要监听对象的属性变化，需要使用deep：true"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#注意2：如果需要监听对象的属性变化，需要使用deep：true"}},[t._v("#")]),t._v(" 注意2：如果需要监听对象的属性变化，需要使用deep：true")]),t._v(" "),a("blockquote",[a("ul",[a("li",[t._v("前提是这个属性已经存在于对象中，如果不存在则需要使用this.$set才行")])])]),t._v(" "),a("h4",{attrs:{id:"注意3：监听对象时，拿不到oldvalue，因为指向同一内存地址；"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#注意3：监听对象时，拿不到oldvalue，因为指向同一内存地址；"}},[t._v("#")]),t._v(" 注意3：监听对象时，拿不到oldValue，因为指向同一内存地址；")]),t._v(" "),a("h4",{attrs:{id:"注意4：监听数组时，直接操作数组的下标或更改长度，就算是加-deep-true-也是监听不到的。"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#注意4：监听数组时，直接操作数组的下标或更改长度，就算是加-deep-true-也是监听不到的。"}},[t._v("#")]),t._v(" 注意4：监听数组时，直接操作数组的下标或更改长度，就算是加 deep: true 也是监听不到的。")]),t._v(" "),a("p",[a("strong",[t._v("其实变异方法就是会改变原数组的方法，非变异方法则不会改变原数组")])]),t._v(" "),a("blockquote",[a("ul",[a("li",[t._v("数组的7个变异方法: push()、pop()、shift()、unshift()、splice()、sort()、reverse()")]),t._v(" "),a("li",[t._v("非变异方法：concat() 和 slice()、join()等\n"),a("strong",[t._v("以下有效")])]),t._v(" "),a("li",[t._v("this.$set( this.arr, '0', 666)")]),t._v(" "),a("li",[t._v("结论：监听数组也是监听它的内存地址，但是deep加不加都是无所谓的。")])])]),t._v(" "),a("p",[a("strong",[t._v("扩展：Vue 实例将会在实例化时调用 $watch()，遍历 watch 对象的每一个属性。")])]),t._v(" "),a("h4",{attrs:{id:"什么时候用-："}},[a("a",{staticClass:"header-anchor",attrs:{href:"#什么时候用-："}},[t._v("#")]),t._v(" 什么时候用?：")]),t._v(" "),a("blockquote",[a("ul",[a("li",[t._v("1.如果一个数据依赖于其他数据做计算，那么把这个数据设计为computed的.")]),t._v(" "),a("li",[t._v("2.如果你需要在某个数据变化时做一些事情，使用watch来观察这个数据变化.")])])])])}),[],!1,null,null,null);e.default=s.exports}}]);