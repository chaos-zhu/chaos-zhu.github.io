(window.webpackJsonp=window.webpackJsonp||[]).push([[172],{497:function(t,e,a){"use strict";a.r(e);var s=a(0),r=Object(s.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"nexttick的使用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#nexttick的使用"}},[t._v("#")]),t._v(" $nextTick的使用")]),t._v(" "),a("h2",{attrs:{id:"vue-是异步执行-dom-更新"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue-是异步执行-dom-更新"}},[t._v("#")]),t._v(" Vue 是异步执行 DOM 更新")]),t._v(" "),a("blockquote",[a("p",[t._v("1、只要观察到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据改变。如果同一个 watcher 被多次触发，只会被推入到队列中一次。")])]),t._v(" "),a("blockquote",[a("p",[t._v("2、然后，在下一个的事件循环 tick 中，Vue 刷新队列并执行实际 (已去重的) 工作。Vue 在内部尝试对异步队列使用原生的 Promise.then 和 MessageChannel，如果执行环境不支持，会采用 setTimeout(fn, 0) 代替。")])]),t._v(" "),a("h2",{attrs:{id:"总结"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[t._v("#")]),t._v(" 总结")]),t._v(" "),a("blockquote",[a("ul",[a("li",[t._v("汇总data的修改，一次性更新视图，为的是减少DOM的操作次数，提高性能。")])])]),t._v(" "),a("p",[a("strong",[t._v("如果修改了data，则$nextTick会在DOM渲染之后被触发，可以获取最新的节点。")])]),t._v(" "),a("p",[a("img",{attrs:{src:"https://user-images.githubusercontent.com/44160914/78561424-4ba15a00-784a-11ea-881a-ad911f4c26a0.png",alt:"$nextTick用法"}})])])}),[],!1,null,null,null);e.default=r.exports}}]);