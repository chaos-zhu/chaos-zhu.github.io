(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{339:function(t,v,_){"use strict";_.r(v);var s=_(0),r=Object(s.a)({},(function(){var t=this,v=t.$createElement,_=t._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h1",{attrs:{id:"数组-链表-堆栈-队列"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#数组-链表-堆栈-队列"}},[t._v("#")]),t._v(" 数组&链表&堆栈&队列")]),t._v(" "),_("h2",{attrs:{id:"数组：顺序存储【连续地址存储】"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#数组：顺序存储【连续地址存储】"}},[t._v("#")]),t._v(" 数组：顺序存储【连续地址存储】")]),t._v(" "),_("p",[_("strong",[t._v("查找")]),t._v("：通过index直接定位 --\x3e O(1)")]),t._v(" "),_("p",[_("strong",[t._v("插入")]),t._v("分为以下两种情况：")]),t._v(" "),_("ul",[_("li",[t._v("插到末尾 --\x3e O(1)")]),t._v(" "),_("li",[t._v("查到中间需要移动添加元素后面的所有元素位置, 再添加元素 --\x3e O(n)")])]),t._v(" "),_("p",[_("strong",[t._v("删除")]),t._v("分为以下两种情况：")]),t._v(" "),_("ul",[_("li",[_("p",[t._v("删除末尾元素：删除末尾不需要考虑移动元素位置 --\x3e O(1)")])]),t._v(" "),_("li",[_("p",[t._v("删除中间需要移动删除元素后面的所有元素位置, 再删除元素 --\x3e O(n)")])])]),t._v(" "),_("h2",{attrs:{id:"链表：链式存储【非连续地址储存】"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#链表：链式存储【非连续地址储存】"}},[t._v("#")]),t._v(" 链表：链式存储【非连续地址储存】")]),t._v(" "),_("p",[t._v("【"),_("strong",[t._v("链式存储")]),t._v("】(next --\x3e 指针链向下一个节点)")]),t._v(" "),_("ul",[_("li",[t._v("查找：O(n)")]),t._v(" "),_("li",[t._v("插入： O(1)")])]),t._v(" "),_("h2",{attrs:{id:"栈-stack-又称【堆栈】"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#栈-stack-又称【堆栈】"}},[t._v("#")]),t._v(" 栈(stack)又称【堆栈】")]),t._v(" "),_("ul",[_("li",[_("p",[_("strong",[t._v("后入先出")]),t._v(" - Last In First Out("),_("strong",[t._v("LIFO")]),t._v(")【eg：在桌面上堆盘子，只能从栈顶取】")])]),t._v(" "),_("li",[_("p",[t._v("栈是只能在一端"),_("strong",[t._v("栈顶top")]),t._v("进行插入与删除。另一端是"),_("strong",[t._v("栈底bottom")]),t._v("。当表中没有元素时称"),_("strong",[t._v("空栈")]),t._v("。")])]),t._v(" "),_("li",[_("p",[t._v("栈具有记忆作用，程序设计中的函数调用、递归调用等都是通过栈实现的【"),_("router-link",{attrs:{to:"/front-end/other/递归调用导致的栈溢出.html"}},[t._v("递归调用导致的栈溢出")]),t._v("】")],1)])]),t._v(" "),_("h2",{attrs:{id:"队列-queue"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#队列-queue"}},[t._v("#")]),t._v(" 队列(queue)")]),t._v(" "),_("ul",[_("li",[_("p",[_("strong",[t._v("先进先出")]),t._v(" - First In First Out("),_("strong",[t._v("FIFO")]),t._v(")【eg：生活中的排队，只能从栈顶取】")])]),t._v(" "),_("li",[_("p",[t._v("队列只能在表的一端("),_("strong",[t._v("队头")]),t._v(")进行删除操作、在另一端("),_("strong",[t._v("队尾")]),t._v(")进行删除操作")])])]),t._v(" "),_("div",{staticClass:"custom-block warning"},[_("p",{staticClass:"custom-block-title"},[t._v("注意别混淆")]),t._v(" "),_("p",[_("strong",[t._v("数据结构")]),t._v("与"),_("strong",[t._v("内存管理")]),t._v("中的"),_("strong",[t._v("堆和栈的区别")])]),t._v(" "),_("ul",[_("li",[_("p",[_("strong",[t._v("数据结构")]),t._v(" 中的stack我们叫做堆栈，其实是两种不同的数据结构,即堆和栈，堆实质上是满足一定性质的完全二叉树，而栈是“后进先出”的一种线性数据结构，它们与队列queue数据结构相对，queue是先进先出的线性数据结构，它们都是数据结构中的概念")])]),t._v(" "),_("li",[_("p",[_("strong",[t._v("内存管理")]),t._v(" 中的堆栈，其实应该分为“堆heap”和“栈stack”两个部分，在内存管理中发挥不同的作用。以js数据类型为例，基本数据类型的存储在栈区中，而引用类型的值则存储在堆区中")])])])])])}),[],!1,null,null,null);v.default=r.exports}}]);